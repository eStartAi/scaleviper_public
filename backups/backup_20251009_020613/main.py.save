import os
import logging
from dotenv import load_dotenv
from flask import Flask, request, jsonify

from flask import Flask, jsonify
from log_trades import read_trades, read_errors

app = Flask(__name__)

@app.route("/dashboard", methods=["GET"])
def dashboard():
    return jsonify({
        "recent_trades": read_trades(limit=20),
        "recent_errors": read_errors(limit=20)
    })


# === Load config ===
from config import (
    DRY_RUN, DEFAULT_SL_PCT, DEFAULT_TP_PCT,
    DAILY_PROFIT_TARGET, MAX_DAILY_LOSS, MAX_CONSECUTIVE_LOSSES,
    TELEGRAM_BOT_TOKEN, TELEGRAM_CHAT_ID, WATCHLIST
)
from signal_engine import calculate_signal_score
from risk_guard import calculate_position_size, should_continue_trading
from trade_executor import place_trade
from daily_manager import load_state, reset_daily_stats_if_needed, update_after_trade, check_trading_allowed
from notifier import send_telegram_message, build_daily_summary
from utils.risk import validate_risk
from utils.logger import log_trade

# Load environment
load_dotenv()
RUN_MODE = os.getenv("RUN_MODE", "auto").lower()   # "auto" or "webhook"
WEBHOOK_SECRET = os.getenv("WEBHOOK_SECRET", "change_me_secret")
APP_PORT = int(os.getenv("APP_PORT", 5001))
EXCHANGE = os.getenv("DEFAULT_BROKER", "kraken")

# Logging setup
os.makedirs("logs", exist_ok=True)
logging.basicConfig(
    filename="logs/scaleviper.log",
    level=logging.INFO,
    format="%(asctime)s %(levelname)s: %(message)s"
)

# ===================================================
# AUTO MODE: Self-Trading ScaleViper
# ===================================================
def fetch_indicator_data(pair):
    """Mock/replace with real exchange or data feed."""
    return {
        'rsi': 29,
        'macd_cross': True,
        'ema50': 105,
        'ema200': 100,
        'atr': 1.4,
        'atr_avg': 1.1,
        'volume': 8000,
        'volume_ma': 5000,
        'candle_pattern': 'bullish_engulfing',
        'spread': 0.0015,
        'price': 1540,
        'recent_high': 1535
    }

def run_auto_bot():
    print("ü§ñ ScaleViper Auto Mode starting...")
    state = load_state()
    state = reset_daily_stats_if_needed(state)

    allowed, reason = check_trading_allowed(state)
    print("Bot status:", reason)
    if not allowed:
        send_telegram_message(reason)
        return

    for pair in WATCHLIST:
        data = fetch_indicator_data(pair)
        score = calculate_signal_score(data)
        print(f"{pair} ‚Üí Signal Score: {score}/10")

        if score < 7:
            continue

        balance = state['current_balance']
        price = data['price']
        stop_loss_pct = DEFAULT_SL_PCT

        size = calculate_position_size(balance, score, price, stop_loss_pct)
        if size == 0:
            continue

        # Execute trade
        result = place_trade(pair=pair, side='buy', price=price, size=size, confidence_score=score)
        log_trade(result['data'])

        # Simulate win/loss for demo
        trade_won = True if score >= 8 else False
        pnl_pct = 2.5 if trade_won else -2.0
        state = update_after_trade(state, pnl_pct, trade_won)

        allowed, reason = check_trading_allowed(state)
        if not allowed:
            print("üîí Halting after this trade:", reason)
            break

    summary = build_daily_summary(state)
    send_telegram_message(summary)
    print(summary)


# ===================================================
# WEBHOOK MODE: Signal Executor
# ===================================================
app = Flask(__name__)

@app.route("/webhook", methods=["POST"])
def webhook():
    data = request.get_json()

    # 1. Security check
    if data.get("secret") != WEBHOOK_SECRET:
        logging.warning("‚ùå Unauthorized webhook attempt.")
        return jsonify({"error": "Invalid secret"}), 403

    try:
        symbol = data.get("symbol")
        side = data.get("side")  # buy/sell
        order_type = data.get("type", "market")
        price = float(data.get("price", 0))
        size = float(data.get("size", 0))

        logging.info(f"üì© Incoming signal: {data}")

        # 2. Validate risk
        if not validate_risk(symbol, side, price, size):
            logging.warning("‚ö†Ô∏è Risk validation failed.")
            return jsonify({"error": "Risk check failed"}), 400

        # 3. Execute trade
        if DRY_RUN:
            logging.info(f"üß™ DRY_RUN: Simulated {side.upper()} {symbol} @ {price}")
            trade_result = {"status": "dry_run", "symbol": symbol, "side": side, "price": price}
        else:
            trade_result = place_trade(symbol, side, price, size)

        # 4. Log trade
        log_trade(trade_result)

        return jsonify({"response": trade_result})

    except Exception as e:
        logging.error(f"üí• Error: {str(e)}", exc_info=True)
        return jsonify({"error": str(e)}), 500


# ===================================================
# MAIN ENTRY
# ===================================================
if __name__ == "__main__":
    if RUN_MODE == "auto":
        run_auto_bot()
    elif RUN_MODE == "webhook":
        print(f"üöÄ ScaleViper Webhook Mode starting on port {APP_PORT} (Exchange={EXCHANGE}, DRY_RUN={DRY_RUN})")
        app.run(host="0.0.0.0", port=APP_PORT)
    else:
        print("‚ùå Invalid RUN_MODE. Use 'auto' or 'webhook'.")

 
